<!DOCTYPE HTML>
<html xmlns:th="http://www.thymeleaf.org">

<head>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/0.4.14/leaflet.draw.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.3/dist/leaflet.css"
        integrity="sha256-kLaT2GOSpHechhsozzB+flnD+zUyjE2LlfWPgU04xyI=" crossorigin="" />
    <link th:href="@{/style.css}" rel="stylesheet" />
    <script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js"
        integrity="sha256-WBkoXOwTeyKclOHuWtc+i2uENFpDZ9YPdf5Hf+D7ewM=" crossorigin=""></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/0.4.14/leaflet.draw.js"></script>
    <script src='https://unpkg.com/@turf/turf@6/turf.min.js'></script>
   

</head>

<body>
    <div class="container">
        <div id="map">
        </div>
        <div class="side">
            <div class="sideItem">
                <div>
                    <button type="button" onclick="sendBsms();">Send BSMs to Kafka Topic</button>
                </div>
                <div>
                    <button type="button" onclick="downloadBsms();">Download BSMs as line-delimited JSON</button>
                </div>
                <div>
                    Upload BSMs (line-delimited JSON)
                    <input type="file" accept=".jsonl,.ndjson,.csv,.json" onchange="uploadBsms(this);"/>
                </div>
                <div>
                    Upload BSM template
                    <input type="file" id="btnTemplateUpload" accept=".json" onchange="uploadBsmTemplate(this);" />
                </div>
                <div>
                    Upload MAP GeoJSON
                    <input type="file" id="btnMapUpload" accept=".geojson,.json" onchange="uploadMapGeojson(this);" />
                </div>
                <div>
                    <button type="button" onclick="downloadMapGeojson();">Download MAP GeoJSON</button>
                </div>
            </div>
            <div class="sideItem">
                BSM Template
            </div>
            <div class="sideItem jsonDocument" id="bsmTemplate" contenteditable="true" spellcheck="false">
                
            </div>
        </div>
    </div>
</body>
<script>
    var map = L.map('map').setView([39.5952649, -105.0914122], 19);

    /* Base Maps */
    var osmUrl = 'https://tile.openstreetmap.org/{z}/{x}/{y}.png';
    var osmAttrib = '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>';
    var googUrl = 'https://mt1.google.com/vt/lyrs=y&x={x}&y={y}&z={z}';
    var googAttrib = 'Google Maps';
    /* See https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html#javascript-inlining */
    var mapboxUrl = '[(${mapboxTileEndpoint})]';
    console.log(mapboxUrl);
    var mapboxAttrib = 'Mapbox';

    var empty = L.tileLayer('', { maxZoom: 22 });
    var osm = L.tileLayer(osmUrl, { maxZoom: 19, attribution: osmAttrib });
    var goog = L.tileLayer(googUrl, { maxZoom: 22, attribution: googAttrib });
    var mapbox = L.tileLayer(mapboxUrl, {
        maxZoom: 22,
        attribution: mapboxAttrib
    });
    var drawnItems = new L.FeatureGroup();

    var bsmList = [];  /* Array of timestamps/ BSM locations */

    var layerControl = L.control.layers({
        'No Base Map': empty.addTo(map),
        'Open Street Map': osm.addTo(map),
        'Google Hybrid': goog.addTo(map),
        'Mapbox Satellite Streets': mapbox.addTo(map)
    }, { 'Draw BSM Layer': drawnItems }, { positiion: 'topright', collapsed: false }).addTo(map);


    /* Shape draw controls */

    map.addLayer(drawnItems);



    var drawControl = new L.Control.Draw({
        position: 'topleft',
        draw: {
            polyline: false,
            polygon: false,
            rectangle: false,
            circle: false,
            marker: false,
            circlemarker: {
                color: '#f00',
                fillOpacity: 0.9,
                stroke: false,
                radius: 5
            }
        },
        edit: {
            featureGroup: drawnItems,
            remove: true
        }
    });
    map.addControl(drawControl);


    map.on(L.Draw.Event.CREATED, function (e) {
        var type = e.layerType,
            layer = e.layer;
        if (type == 'circlemarker') {

            drawnItems.addLayer(layer);
            console.log('Placed point');
            console.log(layer);

            var lon = layer._latlng.lng;
            var lat = layer._latlng.lat;

            /* Save the coordinates with the current timestamp */
            var ts = Date.now();
            var bsm = { timestamp: ts, coords: [lon, lat], heading: 0 };

            /* Tag the layer with the bsm timestamp so we can find it to update or delete */
            layer.bsmTimestamp = ts;

            bsmList.push(bsm);
            console.log(bsmList);

            /* Keep circlemarker button in edit mode
               TODO Figure out some way to do this other than this hack */
            throw 'Throwing exception to keep the circlemarker in edit mode.  Not ideal but it works.'

        } else {
            console.log('layerType ' + type + ' not used');
        }
    });


    map.on('draw:edited', function (e) {
        /* TODO update bsmList */
        console.log(e);

    });

    map.on('draw:deleted', function (e) {
        console.log(e);
        /* Remove all items */
        bsmList.length = 0;
        /* TODO: Don't assume all items were deleted */
    });

    async function getMapGeojson() {
        const response = await fetch('map_wadsworth_and_coalmine.geojson');
        const mapGeojson = await response.json();
        console.log("MAP Geojson:");
        console.log(mapGeojson);
        const geojsonLayer = L.geoJSON(mapGeojson, {
            style: {
                color: '#f0f',
                width: '1px',
                opacity: 0.7
            }
        }).addTo(map);
        layerControl.addOverlay(geojsonLayer, 'MAP Geojson');
    }


    getMapGeojson();

    function sendBsms() {
        var result = sendBsmsAsync().then(successCallback, failureCallback);
        console.log("Sent BSMs with response");
        console.log(result);
    }

    async function sendBsmsAsync() {
        console.log(bsmList);
        // Calculate bearing and speed
        addHeading(bsmList);
        console.log(bsmList);
        // If there is a BSM template, attach it
        let bsmTemplateObj = null;
        try {
            let bsmText = document.getElementById("bsmTemplate").innerText;
            let bsmTemplateObj = JSON.parse(bsmText);
        } catch { 
            /* Ignore exception if there is no bsm template */
        }
        postData = { bsmList: bsmList, bsmTemplate: bsmTemplateObj };
        const response = await fetch('/createBsmMessages', {
            method: 'POST',
            cache: 'no-cache',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(postData)
        });
        return response;
    }

    function successCallback(e) {
        console.log("success");
        console.log(e);
    }

    function failureCallback(e) {
        console.log("failure");
        console.log(e);
    }

    function uploadBsms(e) {
        console.log("uploadBsms");
        if (e?.files.length > 0) {
            console.log(e.files[0]);
        }
    }

    function uploadBsmTemplate(e) {
        console.log("uploadBsmTemplate")
        if (e?.files.length > 0) {
            let file = e.files[0];
            console.log(file);
            let objUrl = window.URL.createObjectURL(file);
            console.log(objUrl);
            file.text().then(text => {
                var json = JSON.parse(text);
                console.log(json);
                document.getElementById("bsmTemplate").innerText = JSON.stringify(json, null, 2);
            });
        }
    }

    function uploadMapGeojson(e) {
        console.log("uploadMapGeojson");
        if (e?.files.length > 0) {
            console.log(e.files[0]);
        }
    }

    function addHeading(bsmArr) {
        if (bsmArr.length <= 1) {
            return;
        }

        for (var i = 1; i < bsmArr.length; i++) {
            // Bearing and speed based on the previous point
            var point1 = turf.point(bsmArr[i-1].coords);
            var point2 = turf.point(bsmArr[i].coords);
            var heading = turf.bearingToAzimuth(turf.bearing(point1, point2));

            var distanceMeters = turf.distance(point1, point2, { units: 'kilometers' }) * 1000;

            var t1 = bsmArr[i-1].timestamp;
            var t2 = bsmArr[i].timestamp;
            var speed = distanceMeters/(t2 - t2);

            bsmArr[i].heading = heading;
            bsmArr[i].speed = speed;
            if (i == 1) {
                // First point same as second
                bsmArr[0].heading = heading;
                bsmArr[0].speed = speed;
            }
        }
    }


</script>

</html>